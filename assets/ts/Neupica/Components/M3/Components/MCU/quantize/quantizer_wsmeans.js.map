{"version":3,"file":"quantizer_wsmeans.js","sourceRoot":"","sources":["../../quantize/quantizer_wsmeans.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *      http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {LabPointProvider} from './lab_point_provider';\r\n\r\nconst MAX_ITERATIONS = 10;\r\nconst MIN_MOVEMENT_DISTANCE = 3.0;\r\n\r\n/**\r\n * An image quantizer that improves on the speed of a standard K-Means algorithm\r\n * by implementing several optimizations, including deduping identical pixels\r\n * and a triangle inequality rule that reduces the number of comparisons needed\r\n * to identify which cluster a point should be moved to.\r\n *\r\n * Wsmeans stands for Weighted Square Means.\r\n *\r\n * This algorithm was designed by M. Emre Celebi, and was found in their 2011\r\n * paper, Improving the Performance of K-Means for Color Quantization.\r\n * https://arxiv.org/abs/1101.0395\r\n */\r\n// material_color_utilities is designed to have a consistent API across\r\n// platforms and modular components that can be moved around easily. Using a\r\n// class as a namespace facilitates this.\r\n//\r\n// tslint:disable-next-line:class-as-namespace\r\nexport class QuantizerWsmeans {\r\n  /**\r\n   * @param inputPixels Colors in ARGB format.\r\n   * @param startingClusters Defines the initial state of the quantizer. Passing\r\n   *     an empty array is fine, the implementation will create its own initial\r\n   *     state that leads to reproducible results for the same inputs.\r\n   *     Passing an array that is the result of Wu quantization leads to higher\r\n   *     quality results.\r\n   * @param maxColors The number of colors to divide the image into. A lower\r\n   *     number of colors may be returned.\r\n   * @return Colors in ARGB format.\r\n   */\r\n  static quantize(\r\n      inputPixels: number[], startingClusters: number[],\r\n      maxColors: number): Map<number, number> {\r\n    const pixelToCount = new Map<number, number>();\r\n    const points = new Array<number[]>();\r\n    const pixels = new Array<number>();\r\n    const pointProvider = new LabPointProvider();\r\n    let pointCount = 0;\r\n    for (let i = 0; i < inputPixels.length; i++) {\r\n      const inputPixel = inputPixels[i];\r\n      const pixelCount = pixelToCount.get(inputPixel);\r\n      if (pixelCount === undefined) {\r\n        pointCount++;\r\n        points.push(pointProvider.fromInt(inputPixel));\r\n        pixels.push(inputPixel);\r\n        pixelToCount.set(inputPixel, 1);\r\n      } else {\r\n        pixelToCount.set(inputPixel, pixelCount + 1);\r\n      }\r\n    }\r\n\r\n    const counts = new Array<number>();\r\n    for (let i = 0; i < pointCount; i++) {\r\n      const pixel = pixels[i];\r\n      const count = pixelToCount.get(pixel);\r\n      if (count !== undefined) {\r\n        counts[i] = count;\r\n      }\r\n    }\r\n\r\n    let clusterCount = Math.min(maxColors, pointCount);\r\n    if (startingClusters.length > 0) {\r\n      clusterCount = Math.min(clusterCount, startingClusters.length);\r\n    }\r\n\r\n    const clusters = new Array<number[]>();\r\n    for (let i = 0; i < startingClusters.length; i++) {\r\n      clusters.push(pointProvider.fromInt(startingClusters[i]));\r\n    }\r\n    const additionalClustersNeeded = clusterCount - clusters.length;\r\n    if (startingClusters.length === 0 && additionalClustersNeeded > 0) {\r\n      for (let i = 0; i < additionalClustersNeeded; i++) {\r\n        const l = Math.random() * 100.0;\r\n        const a = Math.random() * (100.0 - (-100.0) + 1) + -100;\r\n        const b = Math.random() * (100.0 - (-100.0) + 1) + -100;\r\n\r\n        clusters.push(new Array(l, a, b));\r\n      }\r\n    }\r\n\r\n    const clusterIndices = new Array<number>();\r\n    for (let i = 0; i < pointCount; i++) {\r\n      clusterIndices.push(Math.floor(Math.random() * clusterCount));\r\n    }\r\n\r\n    const indexMatrix = new Array<number[]>();\r\n    for (let i = 0; i < clusterCount; i++) {\r\n      indexMatrix.push(new Array<number>());\r\n      for (let j = 0; j < clusterCount; j++) {\r\n        indexMatrix[i].push(0);\r\n      }\r\n    }\r\n\r\n    const distanceToIndexMatrix = new Array<DistanceAndIndex[]>();\r\n    for (let i = 0; i < clusterCount; i++) {\r\n      distanceToIndexMatrix.push(new Array<DistanceAndIndex>());\r\n      for (let j = 0; j < clusterCount; j++) {\r\n        distanceToIndexMatrix[i].push(new DistanceAndIndex());\r\n      }\r\n    }\r\n\r\n\r\n    const pixelCountSums = new Array<number>();\r\n    for (let i = 0; i < clusterCount; i++) {\r\n      pixelCountSums.push(0);\r\n    }\r\n    for (let iteration = 0; iteration < MAX_ITERATIONS; iteration++) {\r\n      for (let i = 0; i < clusterCount; i++) {\r\n        for (let j = i + 1; j < clusterCount; j++) {\r\n          const distance = pointProvider.distance(clusters[i], clusters[j]);\r\n          distanceToIndexMatrix[j][i].distance = distance;\r\n          distanceToIndexMatrix[j][i].index = i;\r\n          distanceToIndexMatrix[i][j].distance = distance;\r\n          distanceToIndexMatrix[i][j].index = j;\r\n        }\r\n        distanceToIndexMatrix[i].sort();\r\n        for (let j = 0; j < clusterCount; j++) {\r\n          indexMatrix[i][j] = distanceToIndexMatrix[i][j].index;\r\n        }\r\n      }\r\n\r\n      let pointsMoved = 0;\r\n      for (let i = 0; i < pointCount; i++) {\r\n        const point = points[i];\r\n        const previousClusterIndex = clusterIndices[i];\r\n        const previousCluster = clusters[previousClusterIndex];\r\n        const previousDistance = pointProvider.distance(point, previousCluster);\r\n        let minimumDistance = previousDistance;\r\n        let newClusterIndex = -1;\r\n        for (let j = 0; j < clusterCount; j++) {\r\n          if (distanceToIndexMatrix[previousClusterIndex][j].distance >=\r\n              4 * previousDistance) {\r\n            continue;\r\n          }\r\n          const distance = pointProvider.distance(point, clusters[j]);\r\n          if (distance < minimumDistance) {\r\n            minimumDistance = distance;\r\n            newClusterIndex = j;\r\n          }\r\n        }\r\n        if (newClusterIndex !== -1) {\r\n          const distanceChange = Math.abs(\r\n              (Math.sqrt(minimumDistance) - Math.sqrt(previousDistance)));\r\n          if (distanceChange > MIN_MOVEMENT_DISTANCE) {\r\n            pointsMoved++;\r\n            clusterIndices[i] = newClusterIndex;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (pointsMoved === 0 && iteration !== 0) {\r\n        break;\r\n      }\r\n\r\n      const componentASums = new Array<number>(clusterCount).fill(0);\r\n      const componentBSums = new Array<number>(clusterCount).fill(0);\r\n      const componentCSums = new Array<number>(clusterCount).fill(0);\r\n\r\n      for (let i = 0; i < clusterCount; i++) {\r\n        pixelCountSums[i] = 0;\r\n      }\r\n      for (let i = 0; i < pointCount; i++) {\r\n        const clusterIndex = clusterIndices[i];\r\n        const point = points[i];\r\n        const count = counts[i];\r\n        pixelCountSums[clusterIndex] += count;\r\n        componentASums[clusterIndex] += (point[0] * count);\r\n        componentBSums[clusterIndex] += (point[1] * count);\r\n        componentCSums[clusterIndex] += (point[2] * count);\r\n      }\r\n\r\n      for (let i = 0; i < clusterCount; i++) {\r\n        const count = pixelCountSums[i];\r\n        if (count === 0) {\r\n          clusters[i] = [0.0, 0.0, 0.0];\r\n          continue;\r\n        }\r\n        const a = componentASums[i] / count;\r\n        const b = componentBSums[i] / count;\r\n        const c = componentCSums[i] / count;\r\n        clusters[i] = [a, b, c];\r\n      }\r\n    }\r\n\r\n    const argbToPopulation = new Map<number, number>();\r\n    for (let i = 0; i < clusterCount; i++) {\r\n      const count = pixelCountSums[i];\r\n      if (count === 0) {\r\n        continue;\r\n      }\r\n\r\n      const possibleNewCluster = pointProvider.toInt(clusters[i]);\r\n      if (argbToPopulation.has(possibleNewCluster)) {\r\n        continue;\r\n      }\r\n\r\n      argbToPopulation.set(possibleNewCluster, count);\r\n    }\r\n    return argbToPopulation;\r\n  }\r\n}\r\n\r\n/**\r\n *  A wrapper for maintaining a table of distances between K-Means clusters.\r\n */\r\nclass DistanceAndIndex {\r\n  distance: number = -1;\r\n  index: number = -1;\r\n}\r\n"]}